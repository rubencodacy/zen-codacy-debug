#!/usr/bin/env python3
# Copyright (c) 2014 The Bitcoin Core developers
# Copyright (c) 2018 The Zencash developers
# Distributed under the MIT software license, see the accompanying
# file COPYING or http://www.opensource.org/licenses/mit-license.php.
from test_framework.test_framework import BitcoinTestFramework
from test_framework.test_framework import ForkHeights
from test_framework.authproxy import JSONRPCException
from test_framework.util import assert_true, assert_equal, initialize_chain_clean, get_epoch_data, \
    start_nodes, sync_blocks, sync_mempools, connect_nodes_bi, mark_logs, \
    swap_bytes, colorize as cc
from test_framework.mc_test.mc_test import *
from decimal import Decimal

DEBUG_MODE = 1
NUMB_OF_NODES = 2
EPOCH_LENGTH = 25
FT_SC_FEE = Decimal('0')
MBTR_SC_FEE = Decimal('0')
CERT_FEE = Decimal('0.00015')

"""
Checks the correctness of dependencies generated by the createblocktemplate rpc command.
"""
class sc_cert_depends(BitcoinTestFramework):

    alert_filename = None

    def setup_chain(self, split=False):
        print("Initializing test directory " + self.options.tmpdir)
        initialize_chain_clean(self.options.tmpdir, NUMB_OF_NODES)
        self.firstRound = True
        self.mcTest = CertTestUtils(self.options.tmpdir, self.options.srcdir)

    def setup_network(self, split=False):
        self.nodes = []

        self.nodes = start_nodes(NUMB_OF_NODES, self.options.tmpdir, extra_args=
            [['-debug=py', '-debug=sc', '-debug=mempool', '-debug=net', '-debug=cert', '-debug=zendoo_mc_cryptolib', '-scproofqueuesize=0', '-logtimemicros=1']] * NUMB_OF_NODES)

        for k in range(0, NUMB_OF_NODES-1):
            connect_nodes_bi(self.nodes, k, k+1)

        self.is_network_split = split
        self.sync_all()

    def run_test(self):
        # Preliminary setup for this run
        scversion = 0
        ceasable = True
        sc_name = "sc" + str(scversion) + str(ceasable)
        epoch_length = 0 if not ceasable else EPOCH_LENGTH
        creation_amount = Decimal("10.0")

        if (self.firstRound):
            mark_logs(f"Node 0 mines 150 blocks to mature coinbase", self.nodes, DEBUG_MODE, 'e')
            self.nodes[0].generate(150)
            self.sync_all()

        ########### Test on txs: tx3 depends from tx1 AND tx2
        # (1) node0 creates tx1 and tx2 without mining a block
        taddr1 = self.nodes[0].getnewaddress()
        inputs      = [] #fundrawtransaction will fill the gap
        outputs     = {taddr1: 2.5}
        rawtx       = self.nodes[0].createrawtransaction(inputs, outputs)
        rawtxfund   = self.nodes[0].fundrawtransaction(rawtx)
        signedtx    = self.nodes[0].signrawtransaction(rawtxfund['hex'])
        tx1         = self.nodes[0].sendrawtransaction(signedtx['hex'])
        mark_logs(f"Node 0 generated tx1: " + tx1, self.nodes, DEBUG_MODE, 'g')
        self.sync_all()
        rawtx       = self.nodes[0].createrawtransaction(inputs, outputs)
        rawtxfund   = self.nodes[0].fundrawtransaction(rawtx)
        signedtx    = self.nodes[0].signrawtransaction(rawtxfund['hex'])
        tx2         = self.nodes[0].sendrawtransaction(signedtx['hex'])
        mark_logs(f"Node 0 generated tx2: " + tx2, self.nodes, DEBUG_MODE, 'g')
        self.sync_all()

        # (2) Makes sure that tx1 and tx2 are in every mempool
        assert_true(tx1 in self.nodes[0].getrawmempool())
        assert_true(tx1 in self.nodes[1].getrawmempool())
        assert_true(tx2 in self.nodes[0].getrawmempool())
        assert_true(tx2 in self.nodes[1].getrawmempool())

        # (3) now node0 generates a new tx for node1, using tx1 and tx2 as input
        inputs      = [{'txid': tx1, 'vout': 0}, {'txid': tx2, 'vout': 0}]
        outputs     = { taddr1 : 2.7 }
        rawtx       = self.nodes[0].createrawtransaction(inputs, outputs)
        rawtxfund   = self.nodes[0].fundrawtransaction(rawtx)
        signedtx    = self.nodes[0].signrawtransaction(rawtxfund['hex'])
        tx3         = self.nodes[0].sendrawtransaction(signedtx['hex'])
        mark_logs(f"Node 0 generated tx3: " + tx3, self.nodes, DEBUG_MODE, 'g')
        self.sync_all()

        # (4) getblocktemplate should report the correct dependencies
        ret = self.nodes[0].getblocktemplate()
        for h in ret['transactions']:
            if h['hash'] == tx2 or h['hash'] == tx1:
                assert_equal([], h['depends'])
            if h['hash'] == tx3:
                ord_depend_tx = h['depends'][0]
                assert_equal(ret['transactions'][ord_depend_tx - 1]['hash'], tx1)
                ord_depend_tx = h['depends'][1]
                assert_equal(ret['transactions'][ord_depend_tx - 1]['hash'], tx2)
        mark_logs(f"Assertion passed", self.nodes, DEBUG_MODE, 'y')
        self.sync_all()

        ########### Test on txs: tx3 depends from tx2; tx2 depends from tx1
        # mine a block and clear the mempool
        self.nodes[0].generate(1)
        mark_logs(f"Node 0 mines 1 block to clean the mempool", self.nodes, DEBUG_MODE, 'e')
        self.sync_all()

        # In this scenario we create a chain of dependancies between transaction
        # so that tx3 spends an output of tx2, which in turn spends an output of tx1
        # (1) create tx1
        taddr1 = self.nodes[0].getnewaddress()
        inputs      = [] #fundrawtransaction will fill the gap
        outputs     = { taddr1 : 0.5 }
        rawtx       = self.nodes[0].createrawtransaction(inputs, outputs)
        rawtxfund   = self.nodes[0].fundrawtransaction(rawtx)
        signedtx    = self.nodes[0].signrawtransaction(rawtxfund['hex'])
        tx1         = self.nodes[0].sendrawtransaction(signedtx['hex'])
        mark_logs(f"Node 0 generated tx1: " + tx1, self.nodes, DEBUG_MODE, 'g')
        sync_mempools(self.nodes)

        # (2) create tx2 spending outputs from tx1
        taddr2      = self.nodes[0].getnewaddress()
        inputs      = [{'txid': tx1, 'vout': 0}, {'txid': tx1, 'vout': 1}]
        outputs     = { taddr2 : 0.6 }
        rawtx       = self.nodes[0].createrawtransaction(inputs, outputs)
        rawtxfund   = self.nodes[0].fundrawtransaction(rawtx)
        signedtx    = self.nodes[0].signrawtransaction(rawtxfund['hex'])
        tx2         = self.nodes[0].sendrawtransaction(signedtx['hex'])
        mark_logs(f"Node 0 generated tx2: " + tx2, self.nodes, DEBUG_MODE, 'g')
        sync_mempools(self.nodes)

        # (3) create tx3 spending outputs from tx2
        taddr3      = self.nodes[0].getnewaddress()
        inputs      = [{'txid': tx2, 'vout': 0}, {'txid': tx2, 'vout': 1}]
        outputs     = { taddr3 : 0.7 }
        rawtx       = self.nodes[0].createrawtransaction(inputs, outputs)
        rawtxfund   = self.nodes[0].fundrawtransaction(rawtx)
        signedtx    = self.nodes[0].signrawtransaction(rawtxfund['hex'])
        tx3         = self.nodes[0].sendrawtransaction(signedtx['hex'])
        mark_logs(f"Node 0 generated tx3: " + tx3, self.nodes, DEBUG_MODE, 'g')
        sync_mempools(self.nodes)

        # (4) getblocktemplate should report the correct dependencies
        ret = self.nodes[1].getblocktemplate()
        for h in ret['transactions']:
            if h['hash'] == tx1:
                assert_equal([], h['depends'])
            if h['hash'] == tx2:
                ord_depend_tx = h['depends'][0]
                assert_equal(ret['transactions'][ord_depend_tx - 1]['hash'], tx1)
            if h['hash'] == tx3:
                ord_depend_tx = h['depends'][0]
                assert_equal(ret['transactions'][ord_depend_tx - 1]['hash'], tx2)
        mark_logs(f"Assertion passed", self.nodes, DEBUG_MODE, 'y')
        self.sync_all()


        ########### Test on cerificates: cert2 depends from cert1
        # Do the same for SCs and certificates
        vk1 = self.mcTest.generate_params(sc_name)
        vk2 = self.mcTest.generate_params(sc_name + "2")
        constant1 = generate_random_field_element_hex()
        constant2 = generate_random_field_element_hex()

        cmdInput1 = {
            "version": scversion, "withdrawalEpochLength": epoch_length, "toaddress": "dada",
            "amount": creation_amount, "wCertVk": vk1, "constant": constant1
        }
        cmdInput2 = {
            "version": 2, "withdrawalEpochLength": 0, "toaddress": "effe",
            "amount": creation_amount, "wCertVk": vk2, "constant": constant2
        }

        if (self.firstRound):
            nblocks = ForkHeights['NON_CEASING_SC'] - self.nodes[0].getblockcount()
            mark_logs(f"Node 0 mines {nblocks} blocks to reach NON_CEASING_SC fork", self.nodes, DEBUG_MODE, 'e')
            self.nodes[0].generate(nblocks)
            self.sync_all()
            self.firstRound = False

        # (1) Node0 creates two sidechains with 10.0 coins each
        ret = self.nodes[0].sc_create(cmdInput1)
        scid1 = ret['scid']
        creating_tx_1 = ret['txid']
        scid1_swapped = str(swap_bytes(scid1))
        mark_logs("Node 0 created a     ceasable SC 1: " + scid1, self.nodes, DEBUG_MODE, 'c')
        self.sync_all()

        ret = self.nodes[0].sc_create(cmdInput2)
        scid2 = ret['scid']
        creating_tx_2 = ret['txid']
        scid2_swapped = str(swap_bytes(scid2))
        mark_logs("Node 0 created a non-ceasable SC 2: " + scid2, self.nodes, DEBUG_MODE, 'c')
        self.sync_all()

        # (2) Node 0 mines n blocks to reach the end of epoch 0
        nblocks = epoch_length if ceasable else 2
        mark_logs(f"Node 0 mines {nblocks} blocks to reach the end of epoch 0", self.nodes, DEBUG_MODE, 'e')
        self.nodes[0].generate(nblocks)
        self.sync_all()

        # (3) build and send a certificate. This also will prevent sc to cease
        bwt_amount = Decimal("0.7")
        quality = 5
        new_addr = self.nodes[1].getnewaddress()
        amount_cert_1 = {"address": new_addr, "amount": bwt_amount}

        epoch_number, epoch_cum_tree_hash = get_epoch_data(scid1, self.nodes[1], epoch_length, not ceasable)
        proof = self.mcTest.create_test_proof(sc_name, scid1_swapped, epoch_number, quality, MBTR_SC_FEE, 
                FT_SC_FEE, epoch_cum_tree_hash, constant1, [new_addr], [bwt_amount])
        try:
            cert1 = self.nodes[0].sc_send_certificate(scid1, epoch_number, quality,
                epoch_cum_tree_hash, proof, [amount_cert_1], FT_SC_FEE, MBTR_SC_FEE, CERT_FEE)
            mark_logs(f"Node 0 sent cert1: " + cert1, self.nodes, DEBUG_MODE, 'g')
        except JSONRPCException as e:
            errorString = e.error['message']
            mark_logs(f"Send certificate failed with reason {errorString}", self.nodes, DEBUG_MODE, 'r')
        sync_mempools(self.nodes)

        # (4) node 0 creates cert2 using cert1 as input
        quality = 6
        inputs  = [{'txid' : cert1, 'vout' : 0}]
        amount_from_cert = self.nodes[0].getrawtransaction(cert1,1)['vout'][0]['value']
        amount2 = Decimal("0.4")
        change1 = amount_from_cert - amount2 - CERT_FEE
        outputs = {taddr2 : amount2, self.nodes[1].getnewaddress(): change1}
        new_addr = self.nodes[1].getnewaddress()

        epoch_number, epoch_cum_tree_hash = get_epoch_data(scid1, self.nodes[1], epoch_length, not ceasable)
        proof = self.mcTest.create_test_proof(sc_name, scid1_swapped, epoch_number, quality, MBTR_SC_FEE, 
                FT_SC_FEE, epoch_cum_tree_hash, constant1, [new_addr], [amount2])
        # epoch_number, epoch_cum_tree_hash = get_epoch_data(scid2, self.nodes[1], epoch_length, not ceasable)
        # proof = self.mcTest.create_test_proof(sc_name + "2", scid2_swapped, epoch_number, quality, MBTR_SC_FEE, 
        #         FT_SC_FEE, epoch_cum_tree_hash, constant2, [new_addr], [amount2])
        params = {
            "scid": scid1,
            "quality": quality,
            "endEpochCumScTxCommTreeRoot": epoch_cum_tree_hash,
            "scProof": proof,
            "withdrawalEpochNumber": epoch_number}
        try:
            rawcert     = self.nodes[0].createrawcertificate(inputs, outputs, [{"address": new_addr, "amount": amount2}], params)
            signed_cert = self.nodes[0].signrawtransaction(rawcert)
            cert2       = self.nodes[0].sendrawtransaction(signed_cert['hex'])
            mark_logs(f"Node 0 generated cert2: " + cert2, self.nodes, DEBUG_MODE, 'g')
        except JSONRPCException as e:
            errorString = e.error['message']
            mark_logs(f"Send certificate failed with reason {errorString}", self.nodes, DEBUG_MODE, 'r')
        sync_mempools(self.nodes)

        # Add a transaction, just for test
        temporary_newaddr = self.nodes[0].getnewaddress()
        self.nodes[0].sendtoaddress(temporary_newaddr, 0.12)

        # (5) verify that cert2 depends from cert1
        ret = self.nodes[0].getblocktemplate()
        for h in ret['certificates']:
            if h['hash'] == cert1:
                assert_equal([], h['depends'])
                assert_equal([], h['certdepends'])
            if h['hash'] == cert2:
                assert_equal([], h['depends'])
                ord_depend_cert = h['certdepends'][0]
                assert_equal(ret['certificates'][ord_depend_cert - 1]['hash'], cert1)
        mark_logs(f"Assertion passed", self.nodes, DEBUG_MODE, 'y')
        self.sync_all()


        ########### Test on cerificates: tx3 depends on tx2, cert2 depends from cert1 and tx1, cert3 depends on cert2 and tx3
        # (1) Node 0 mines n blocks to reach the end of epoch 1
        nblocks = epoch_length if ceasable else 2
        mark_logs(f"Node 0 mines {nblocks} blocks to reach the end of epoch 1", self.nodes, DEBUG_MODE, 'e')
        self.nodes[0].generate(nblocks)
        self.sync_all()
        # (1) node0 creates tx1 and tx2 without mining a block (no dependencies)
        taddr1 = self.nodes[0].getnewaddress()
        inputs      = [] #fundrawtransaction will fill the gap
        outputs     = {taddr1: 1.5}
        rawtx       = self.nodes[0].createrawtransaction(inputs, outputs)
        rawtxfund   = self.nodes[0].fundrawtransaction(rawtx)
        signedtx    = self.nodes[0].signrawtransaction(rawtxfund['hex'])
        tx1         = self.nodes[0].sendrawtransaction(signedtx['hex'])
        mark_logs(f"Node 0 generated tx1: " + tx1, self.nodes, DEBUG_MODE, 'g')
        self.sync_all()
        rawtx       = self.nodes[0].createrawtransaction(inputs, outputs)
        rawtxfund   = self.nodes[0].fundrawtransaction(rawtx)
        signedtx    = self.nodes[0].signrawtransaction(rawtxfund['hex'])
        tx2         = self.nodes[0].sendrawtransaction(signedtx['hex'])
        mark_logs(f"Node 0 generated tx2: " + tx2, self.nodes, DEBUG_MODE, 'g')
        self.sync_all()
        # (2) create tx3 spending outputs from tx2
        taddr3      = self.nodes[0].getnewaddress()
        inputs      = [{'txid': tx2, 'vout': 0}, {'txid': tx2, 'vout': 1}]
        outputs     = { taddr3 : 1.0 }
        rawtx       = self.nodes[0].createrawtransaction(inputs, outputs)
        rawtxfund   = self.nodes[0].fundrawtransaction(rawtx)
        signedtx    = self.nodes[0].signrawtransaction(rawtxfund['hex'])
        tx3         = self.nodes[0].sendrawtransaction(signedtx['hex'])
        mark_logs(f"Node 0 generated tx3: " + tx3, self.nodes, DEBUG_MODE, 'g')
        sync_mempools(self.nodes)

        # (3) node 0 creates cert1 (no dependencies)
        bwt_amount = Decimal("0.8")
        quality = 5
        new_addr = self.nodes[1].getnewaddress()
        amount_cert_1 = {"address": new_addr, "amount": bwt_amount}

        epoch_number, epoch_cum_tree_hash = get_epoch_data(scid1, self.nodes[1], epoch_length, not ceasable)
        proof = self.mcTest.create_test_proof(sc_name, scid1_swapped, epoch_number, quality, MBTR_SC_FEE, 
                FT_SC_FEE, epoch_cum_tree_hash, constant1, [new_addr], [bwt_amount])
        try:
            cert1 = self.nodes[0].sc_send_certificate(scid1, epoch_number, quality,
                epoch_cum_tree_hash, proof, [amount_cert_1], FT_SC_FEE, MBTR_SC_FEE, CERT_FEE)
            mark_logs(f"Node 0 sent cert1: " + cert1, self.nodes, DEBUG_MODE, 'g')
        except JSONRPCException as e:
            errorString = e.error['message']
            mark_logs(f"Send certificate failed with reason {errorString}", self.nodes, DEBUG_MODE, 'r')
        sync_mempools(self.nodes)

        # (4) node 0 creates cert2. It depends from tx1 and cert1
        quality = 6
        inputs  = [{'txid' : cert1, 'vout' : 0}, {'txid' : tx1, 'vout' : 1}]
        amount_from_cert = \
                self.nodes[0].getrawtransaction(cert1,1)['vout'][0]['value'] + \
                self.nodes[0].getrawtransaction(tx1,1)['vout'][1]['value']
        amount2 = Decimal("0.5")
        change1 = amount_from_cert - amount2 - CERT_FEE
        outputs = {taddr2 : amount2, self.nodes[1].getnewaddress(): change1}
        new_addr = self.nodes[1].getnewaddress()

        epoch_number, epoch_cum_tree_hash = get_epoch_data(scid1, self.nodes[1], epoch_length, not ceasable)
        proof = self.mcTest.create_test_proof(sc_name, scid1_swapped, epoch_number, quality, MBTR_SC_FEE, 
                FT_SC_FEE, epoch_cum_tree_hash, constant1, [new_addr], [amount2])
        params = {
            "scid": scid1,
            "quality": quality,
            "endEpochCumScTxCommTreeRoot": epoch_cum_tree_hash,
            "scProof": proof,
            "withdrawalEpochNumber": epoch_number}
        try:
            rawcert     = self.nodes[0].createrawcertificate(inputs, outputs, [{"address": new_addr, "amount": amount2}], params)
            signed_cert = self.nodes[0].signrawtransaction(rawcert)
            cert2       = self.nodes[0].sendrawtransaction(signed_cert['hex'])
            mark_logs(f"Node 0 generated cert2: " + cert2, self.nodes, DEBUG_MODE, 'g')
        except JSONRPCException as e:
            errorString = e.error['message']
            mark_logs(f"Send certificate failed with reason {errorString}", self.nodes, DEBUG_MODE, 'r')
        sync_mempools(self.nodes)

        # (5) node 0 creates cert3. It depends from tx3 and cert2
        quality = 7
        inputs  = [{'txid' : cert2, 'vout' : 0}, {'txid' : tx3, 'vout' : 1}]
        amount_from_cert = \
                self.nodes[0].getrawtransaction(cert2,1)['vout'][0]['value'] + \
                self.nodes[0].getrawtransaction(tx3,1)['vout'][1]['value']
        amount3 = Decimal("0.4")
        change1 = amount_from_cert - amount3 - CERT_FEE
        outputs = {taddr3 : amount3, self.nodes[1].getnewaddress(): change1}
        new_addr = self.nodes[1].getnewaddress()

        epoch_number, epoch_cum_tree_hash = get_epoch_data(scid1, self.nodes[1], epoch_length, not ceasable)
        proof = self.mcTest.create_test_proof(sc_name, scid1_swapped, epoch_number, quality, MBTR_SC_FEE, 
                FT_SC_FEE, epoch_cum_tree_hash, constant1, [new_addr], [amount3])
        params = {
            "scid": scid1,
            "quality": quality,
            "endEpochCumScTxCommTreeRoot": epoch_cum_tree_hash,
            "scProof": proof,
            "withdrawalEpochNumber": epoch_number}
        try:
            rawcert     = self.nodes[0].createrawcertificate(inputs, outputs, [{"address": new_addr, "amount": amount3}], params)
            signed_cert = self.nodes[0].signrawtransaction(rawcert)
            cert3       = self.nodes[0].sendrawtransaction(signed_cert['hex'])
            mark_logs(f"Node 0 generated cert3: " + cert3, self.nodes, DEBUG_MODE, 'g')
        except JSONRPCException as e:
            errorString = e.error['message']
            mark_logs(f"Send certificate failed with reason {errorString}", self.nodes, DEBUG_MODE, 'r')
        sync_mempools(self.nodes)

        # (6) verify all the dependencies
        ret = self.nodes[0].getblocktemplate()
        for h in ret['transactions']:
            # tx1 and tx2 do not have any dependency
            if h['hash'] == tx1 or h['hash'] == tx2:
                assert_equal([], h['depends'])
            # tx3 depends from tx2
            if h['hash'] == tx3:
                ord_depend_tx = h['depends'][0]
                assert_equal(ret['transactions'][ord_depend_tx - 1]['hash'], tx2)
        for h in ret['certificates']:
            # cert1 does not have any dependency
            if h['hash'] == cert1:
                assert_equal([], h['depends'])
                assert_equal([], h['certdepends'])
            # cert2 depends from tx1 and cert1
            if h['hash'] == cert2:
                ord_depend_tx = h['depends'][0]
                ord_depend_cert = h['certdepends'][0]
                assert_equal(ret['transactions'][ord_depend_tx - 1]['hash'], tx1)
                assert_equal(ret['certificates'][ord_depend_cert - 1]['hash'], cert1)
            # cert3 depends from tx2 and cert2
            if h['hash'] == cert3:
                ord_depend_tx = h['depends'][0]
                ord_depend_cert = h['certdepends'][0]
                assert_equal(ret['transactions'][ord_depend_tx - 1]['hash'], tx3)
                assert_equal(ret['certificates'][ord_depend_cert - 1]['hash'], cert2)
        mark_logs(f"Assertion passed", self.nodes, DEBUG_MODE, 'y')
        self.sync_all()


        ########### Test on cerificates for non-ceasable sidechains:
        # Mine a block to clean each mempool
        self.nodes[0].generate(1)
        mark_logs(f"Node 0 mines 1 block to clean the mempool", self.nodes, DEBUG_MODE, 'e')
        self.sync_all()

        # (1) node 0 creates cert1 (no dependencies) for epoch 0
        bwt_amount = Decimal("0.8")
        quality = 0
        epoch_length2 = 0
        new_addr = self.nodes[1].getnewaddress()
        amount_cert_1 = {"address": new_addr, "amount": bwt_amount}

        epoch_number, epoch_cum_tree_hash = get_epoch_data(scid2, self.nodes[1], epoch_length2, is_non_ceasing=True, reference_height = self.nodes[0].getblockcount() - 10)
        proof = self.mcTest.create_test_proof(sc_name + "2", scid2_swapped, epoch_number, quality, MBTR_SC_FEE, 
                FT_SC_FEE, epoch_cum_tree_hash, constant2, [new_addr], [bwt_amount])
        try:
            cert1 = self.nodes[0].sc_send_certificate(scid2, epoch_number, quality,
                epoch_cum_tree_hash, proof, [amount_cert_1], FT_SC_FEE, MBTR_SC_FEE, CERT_FEE)
            mark_logs(f"Node 0 sent cert1: " + cert1, self.nodes, DEBUG_MODE, 'g')
        except JSONRPCException as e:
            errorString = e.error['message']
            mark_logs(f"Send certificate failed with reason {errorString}", self.nodes, DEBUG_MODE, 'r')
        sync_mempools(self.nodes)

        # (2) node0 creates tx1 and tx2 without mining a block (no dependencies)
        taddr1 = self.nodes[0].getnewaddress()
        inputs      = [] #fundrawtransaction will fill the gap
        outputs     = {taddr1: 1.0}
        rawtx       = self.nodes[0].createrawtransaction(inputs, outputs)
        rawtxfund   = self.nodes[0].fundrawtransaction(rawtx)
        signedtx    = self.nodes[0].signrawtransaction(rawtxfund['hex'])
        tx1         = self.nodes[0].sendrawtransaction(signedtx['hex'])
        mark_logs(f"Node 0 generated tx1: " + tx1, self.nodes, DEBUG_MODE, 'g')
        self.sync_all()
        rawtx       = self.nodes[0].createrawtransaction(inputs, outputs)
        rawtxfund   = self.nodes[0].fundrawtransaction(rawtx)
        signedtx    = self.nodes[0].signrawtransaction(rawtxfund['hex'])
        tx2         = self.nodes[0].sendrawtransaction(signedtx['hex'])
        mark_logs(f"Node 0 generated tx2: " + tx2, self.nodes, DEBUG_MODE, 'g')
        self.sync_all()

        # (3) node 0 creates cert2 for epoch 1. It depends for epoch and tx from cert1
        bwt_amount = Decimal("0.4")
        new_addr = self.nodes[1].getnewaddress()
        amount_cert_2 = {"address": new_addr, "amount": bwt_amount}

        epoch_number, epoch_cum_tree_hash = get_epoch_data(scid2, self.nodes[1], epoch_length2, is_non_ceasing=True, reference_height = self.nodes[0].getblockcount() - 8)
        proof = self.mcTest.create_test_proof(sc_name + "2", scid2_swapped, epoch_number, quality, MBTR_SC_FEE, 
                FT_SC_FEE, epoch_cum_tree_hash, constant2, [new_addr], [bwt_amount])
        try:
            cert2 = self.nodes[0].sc_send_certificate(scid2, epoch_number, quality,
                epoch_cum_tree_hash, proof, [amount_cert_2], FT_SC_FEE, MBTR_SC_FEE, CERT_FEE)
            mark_logs(f"Node 0 sent cert2: " + cert2, self.nodes, DEBUG_MODE, 'g')
        except JSONRPCException as e:
            errorString = e.error['message']
            mark_logs(f"Send certificate failed with reason {errorString}", self.nodes, DEBUG_MODE, 'r')
        sync_mempools(self.nodes)

        # (4) node 0 creates cert3. It depends from cert2 for the epochs and from tx2 for the txs
        bwt_amount = Decimal("0.2")
        new_addr = self.nodes[1].getnewaddress()
        inputs  = [{'txid' : tx2, 'vout' : 0}]
        amount_from_cert = \
                self.nodes[0].getrawtransaction(tx2,1)['vout'][0]['value']
        change3 = amount_from_cert - bwt_amount - CERT_FEE
        outputs = {new_addr : bwt_amount, self.nodes[1].getnewaddress(): change3}

        epoch_number, epoch_cum_tree_hash = get_epoch_data(scid2, self.nodes[1], epoch_length2, is_non_ceasing=True, reference_height = self.nodes[0].getblockcount() - 6)
        proof = self.mcTest.create_test_proof(sc_name + "2", scid2_swapped, epoch_number, quality, MBTR_SC_FEE, 
                FT_SC_FEE, epoch_cum_tree_hash, constant2, [new_addr], [bwt_amount])
        params = {
            "scid": scid2,
            "quality": quality,
            "endEpochCumScTxCommTreeRoot": epoch_cum_tree_hash,
            "scProof": proof,
            "withdrawalEpochNumber": epoch_number}
        try:
            rawcert     = self.nodes[0].createrawcertificate(inputs, outputs, [{"address": new_addr, "amount": bwt_amount}], params)
            signed_cert = self.nodes[0].signrawtransaction(rawcert)
            cert3       = self.nodes[0].sendrawtransaction(signed_cert['hex'])
            mark_logs(f"Node 0 generated cert3: " + cert3, self.nodes, DEBUG_MODE, 'g')
        except JSONRPCException as e:
            errorString = e.error['message']
            mark_logs(f"Send certificate failed with reason {errorString}", self.nodes, DEBUG_MODE, 'r')
        sync_mempools(self.nodes)

        # (5) verify all the dependencies
        ret = self.nodes[0].getblocktemplate()
        for h in ret['transactions']:
            # tx1 and tx2 do not have any dependency
            if h['hash'] == tx1 or h['hash'] == tx2:
                assert_equal([], h['depends'])
        for h in ret['certificates']:
            # cert1 does not have any dependency
            if h['hash'] == cert1:
                assert_equal([], h['depends'])
                assert_equal([], h['certdepends'])
            # cert2 depends from cert1
            if h['hash'] == cert2:
                ord_depend_cert = h['certdepends'][0]
                assert_equal([], h['depends'])
                assert_equal(ret['certificates'][ord_depend_cert - 1]['hash'], cert1)
            # cert3 depends from tx2 and cert2
            if h['hash'] == cert3:
                ord_depend_tx = h['depends'][0]
                ord_depend_cert = h['certdepends'][0]
                assert_equal(ret['transactions'][ord_depend_tx - 1]['hash'], tx2)
                assert_equal(ret['certificates'][ord_depend_cert - 1]['hash'], cert2)
        mark_logs(f"Assertion passed", self.nodes, DEBUG_MODE, 'y')
        self.sync_all()


if __name__ == '__main__':
    sc_cert_depends().main()
